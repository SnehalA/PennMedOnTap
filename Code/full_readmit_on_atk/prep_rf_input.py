__author__ = 'nlsegerl'


"""
Joins together all the features with the cross validation labels and the ground truth labels to prepare input for
random forest.
"""


from filters import *
from udf_installation import *
from derived_features import *

"""

Joins together the following tables
- basic features (cleaned fields from the UPHS cardiac inpat json)
- drug_topic_features  (the lda features generated by topic modeling of previous 90 days drug histories)
- cross validation labels (eg. per patient id train test split)
- ground truth labels (per patient/visit readmit score)

forms input to be used by subsequent regressor/classifier
"""
def join_tables(ta, basic_features, drug_topic_features, cross_validation_labels, ground_truth_labels, frame_name, overwrite = True):

    if (frame_name in ta.get_frame_names()):
        if (not overwrite):
            return ta.get_frame(frame_name)
        else:
            ta.drop_frames(frame_name)

    print "*** JOINING CROSS VALIDATION LABELS INTO BASIC FEATURES"
    basic_wcrossval = basic_features.join(cross_validation_labels, left_on = PATID, how = 'inner')

    add_udf_files(ta, [uphs_fields])

    """
    Transforms PATID and VISID into a compound key EVENT_ID so we can do those joins.
    """
    def add_compound_key(f):
        from uphs_fields import PATID, VISID, EVENT_ID
        if EVENT_ID in [c for (c,t) in f.schema]:
            f.drop_columns([EVENT_ID])
        f.add_columns(lambda row: row[PATID] + row[VISID], (EVENT_ID, str))
        return f

    basic_wcrossval = add_compound_key(basic_wcrossval)
    ground_truth_labels = add_compound_key(ground_truth_labels)


    if drug_topic_features != None:
        print "*** ADDING IN THE LDA FEATURES"
        with_lda = basic_wcrossval.join(drug_topic_features, EVENT_ID, how = 'inner')
    else:
        with_lda = basic_wcrossval

    print "*** JOINING GROUND TRUTH LABELS INTO FEATURES"
    full = with_lda.join(ground_truth_labels, EVENT_ID, name = frame_name, how = 'inner')

    # drop the temporary frames

    ta.drop_frames([basic_wcrossval, with_lda])

    # grumble:  do we really have to do this? couldn't we just specify to keep only one version of the column?
    full.drop_columns([PATID+'_L', VISID+'_L'])
    full.rename_columns( {PATID+'_R' : PATID,  VISID+'_R':VISID})

    return full



"""
Splits off a training frame by copying the rows in which the CROSS_VALIDATION_CLASS is equal to TRAIN_LABEL
"""
def create_train_table(ta, frame, frame_name, overwrite  = True):

    if (frame_name in ta.get_frame_names()):
        if (not overwrite):
            return ta.get_frame(frame_name)
        else:
            ta.drop_frames(frame_name)
    print "*** creating training frame:  " + frame_name

    train = frame.copy(name = frame_name, where = lambda row: row[CROSS_VALIDATION_CLASS] == TRAIN_LABEL)
    return train

"""
Splits off a testing frame by copying the rows in which the CROSS_VALIDATION_CLASS is equal to TRAIN_LABEL
"""
def create_test_table(ta, frame, frame_name, overwrite = True):


    if (frame_name in ta.get_frame_names()):
        if (not overwrite):
            return ta.get_frame(frame_name)
        else:
            ta.drop_frames(frame_name)
    print "*** creating test frame:  " + frame_name

    test = frame.copy(name = frame_name, where = lambda row: row[CROSS_VALIDATION_CLASS] == TEST_LABEL)
    return test